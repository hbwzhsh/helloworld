The Design

The most important artefacts are actually encapsulated inside Akka, and this is the ActorSystem. Here’s how our simulation uses it:

The QueueSimul object is our starting point (extends App). It starts the ActorSystem, kicks off a TubeStation actor, sends it a “Start” message and then goes to sleep for 10 minutes (configurable). When it wakes up, it sends a “Stop” message to the TubeStation actor, thereby initiating a shutdown of the ActorSystem, and the end of the program. What this means is that our simulation will actually create new clients and send them to be served by ticket machines during 10 minutes, after which no new customer will be created, but existing ones will be processed. When the last client will have been served, the program will actually cease execution.

The TubeStation object is an actor managed by ActorSystem (extends Actor). As you will see in the code, we use logging extensively so all Actor instances also extend ActorLogging to report on their internal condition during execution.
The entry point into TubeStation is the “Start” message sent by its parent which triggers 2 things: 1. Creation of a router of TicketMachine actors and 2. Starting a timer to wait for a new customer arrival. Let’s discuss these points in some more detail.
1. Router: actually, we won’t just create one TicketMachine. Using the configuration file, you can actually activate as many ticket machines as you see fit. When you do so, you create an implicit router giving it 3 pieces of information: the kind of actor it will manage for you, how many of them, and what kind of router you want. Akka offers several kinds of router, but we have experimented with mainly 3 of them: round-robin (router will distribute messages over its actors the one after the other, circularly), smallest-mailbox (whereby the next message will be sent to the actor with the smallest mailbox) and balancing-pool (there isn’t one queue per actor instance any longer: the router manages one single queue).
Other than that, you don’t really manage a router. You just send it the messages you would send to TicketMachine. The router will distribute them to the TicketMachine actors it has created, and it will forward the return messages they sent back to you.
This Router concept is the part which will help us test our various hypotheses. Using smallest-mailbox or round-robin, we simulate one queue per server or here, per ticket machine. Using balancing-pool, we can simulate the usage of one common or single queue: the router will keep messages sent by the parent object in a temporary mailbox, and distribute them to TicketMachine actors as they become available: at any one time, the TicketMachine actors will only contain one message, which they’ll process right away. The burden of managing awaiting messages – or customers – will be managed by the router itself.
2. Customer arrival. This is a “self” message which TubeStation sends to itself each time the timer ticks. And the interval for the next timer is based on a Poisson process. This one can be generated dynamically (based on a configurable average rate arrival), or read from an array of pre-configured values. This last option is of great help when you want to compare 2 runs by just changing some parameters: you are assured that the same number of customers will arrive exactly with the same distribution across your tests. The same goes for customers’ processing time (managed in TicketMachine). So when a new customer arrives, TubeStation packages some information (the customer name and its processing time) into an object which it sends to TicketMachine (through the router).
The TubeStation actor will also listen on the return message from TicketMachine actors. As we’ll see, these messages are objects also, which pack execution metrics so we can report useful information which will help us cross-compare runs.
Finally, the TubeStation will also handle the “Stop” message it receives from QueueSimul. When it receives it, it sends a so-called “PoisonPill” message to the router: this is a message which tells the destination to kill itself. The router will distribute it to the TicketMachine instances it had created. When TicketMachine actors receive the poison pill, they stop accepting new messages (if any new message were sent, it would be dropped in a “dead letter” queue). Still, they will process the messages they have accumulated in their mailbox before stopping execution. When all TicketMachine actors have stopped, the router reports to its parents that everyone is actually dead (itself included) via a Terminated message. This is when the TubeStation will initiate a shutdown of the ActorSystem.

TicketMachine. We have said a lot already about this actor, and there’s not much more to uncover here. It is a rather simple actor which just receives a new customer message from TubeStation via its implicit router parent and simulates a processing time by way of a Sleep timer. Then, it packages some metrics inside a CustomerServiced object which it sends back to its parent (the router is clever enough to know he is not the real parent, and it will forward the message back to TubeStation).